generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

/**
 * =========================
 * ENUMS
 * =========================
 */
enum Role {
  USER
  VENDOR
}

enum BookingStatus {
  PENDING
  CONFIRMED
  DISPATCHED
  ON_ROUTE
  ARRIVED_SITE
  WORK_IN_PROGRESS
  COMPLETED
  CANCELLED
  REFUNDED
}

enum PaymentType {
  CASH
  UPI
  CARD
  BANK_TRANSFER
}

/**
 * =========================
 * MODELS
 * =========================
 */
model User {
  id          Int     @id @default(autoincrement())
  name        String
  email       String  @unique
  password    String
  role        Role    @default(USER)
  phone       String?
  address     String?
  companyName String?
  profileImg  String?

  // Relations
  equipments     Equipment[] @relation("VendorEquipments")
  bookings       Booking[]   @relation("UserBookings")
  vendorBookings Booking[]   @relation("VendorBookings")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([role])
  @@index([email])
}

model Equipment {
  id          Int              @id @default(autoincrement())
  name        String
  type        String
  description String?
  price       Decimal          @db.Decimal(10, 2) // per-day price
  vendorId    Int
  vendor      User             @relation("VendorEquipments", fields: [vendorId], references: [id])
  images      EquipmentImage[]
  createdAt   DateTime         @default(now())
  updatedAt   DateTime?        @updatedAt

  // Business details (e-commerce style)
  brand       String?
  model       String?
  capacity    String? // e.g. "3 Ton", "5 m³"
  year        Int?
  quantity    Int     @default(1)
  rentedCount Int     @default(0) // optional: can be used to track allocations

  // Location details
  baseAddress String?
  landmark    String?
  pincode     String?
  baseLat     Float?
  baseLng     Float?
  perKmRate   Decimal? @db.Decimal(10, 2) // transport cost baseline, optional

  // Relations
  bookings Booking[] @relation("EquipmentBookings")

  @@index([vendorId])
  @@index([type])
  @@index([name])
}

model EquipmentImage {
  id  Int    @id @default(autoincrement())
  url String

  equipmentId Int
  equipment   Equipment @relation(fields: [equipmentId], references: [id], onDelete: Cascade)
  // ^ Ensures deleting an equipment cascades to its images (fixes prior FK error)
}

model Booking {
  id Int @id @default(autoincrement())

  userId      Int
  vendorId    Int
  equipmentId Int

  // Rental window
  pickupDate DateTime
  dropDate   DateTime

  // Site address (normalized)
  address String
  city    String? @default("")
  state   String? @default("")
  pincode String? @default("")
  lat     Float?
  lng     Float?

  // Money + payment
  totalAmount Decimal     @default(0.00) @db.Decimal(10, 2)
  paymentType PaymentType @default(CASH)

  // Status & references
  status      BookingStatus @default(PENDING)
  referenceId String?       @unique
  name        String? // customer name at site (optional)
  notes       String?
  createdAt   DateTime      @default(now())
  updatedAt   DateTime?     @updatedAt

  quantity Int @default(1)

  // Relations
  user      User      @relation("UserBookings", fields: [userId], references: [id], onDelete: Restrict)
  vendor    User      @relation("VendorBookings", fields: [vendorId], references: [id], onDelete: Restrict)
  equipment Equipment @relation("EquipmentBookings", fields: [equipmentId], references: [id], onDelete: Restrict)

  // Tracking timeline
  events      BookingEvent[]
  Transaction Transaction[]

  @@index([userId])
  @@index([vendorId, status, createdAt])
  @@index([equipmentId, pickupDate, dropDate])
}

model BookingEvent {
  id        Int           @id @default(autoincrement())
  bookingId Int
  status    BookingStatus // snapshot status at this event (e.g. DISPATCHED)
  note      String? // free text: "Driver left yard" / "Reached gate"
  lat       Float?
  lng       Float?
  createdAt DateTime      @default(now())

  booking      Booking       @relation(fields: [bookingId], references: [id], onDelete: Cascade)
  transactions Transaction[] // reverse relation

  @@index([bookingId, createdAt])
  @@index([status])
}

model Transaction {
  id                Int      @id @default(autoincrement())
  bookingId         Int?     // ✅ make optional
  amount            Float
  status            String   @default("PENDING")
  razorpayPaymentId String?
  razorpayOrderId   String?
  paymentMethod     String?
  createdAt         DateTime @default(now())

  booking        Booking?      @relation(fields: [bookingId], references: [id], onDelete: Cascade)
  BookingEvent   BookingEvent? @relation(fields: [bookingEventId], references: [id])
  bookingEventId Int?
}
